package org.example;

// 무기,전사 문제 어려웠으면 28강 다시보기!

// 문제 : 아래가 실행되도록 해주세요.

//class Main {
//    public static void main(String[] args) {
//        무기 a무기 = new 칼();
//        a무기.공격();
//        // 출력 : 칼로 공격합니다.
//    }
//}
//
//class 무기 {
//    void 공격(){}
//
//}
//class 칼 extends 무기{
//    void 공격(){
//        System.out.println("칼로 공격합니다.");
//    }
//}

//class Main {
//    public static void main(String[] args) {
//        칼 a칼 = new 칼();
//        a칼 = new 활();
//    }
//}
//class 칼{}
//
//class 활 extends 칼{}


// 문제 : 매개변수를 사용해서 전사가 매번 다르게 공격하도록 해주세요.

class Main {
    public static void main(String[] args) {
        전사 a전사 = new 전사();

        a전사.공격(/* 수정가능지역 시작 */"브라이언", "칼"/* 수정가능지역 끝 */);
        // 브라이언이(가) 칼(으)로 공격합니다.
        a전사.재공격();
        // 브라이언이(가) 칼(으)로 공격합니다.
        a전사.공격(/* 수정가능지역 시작 */"필립", "창" /* 수정가능지역 끝 */);
        // 필립이(가) 창(으)로 공격합니다.

        a전사.공격(/* 수정가능지역 시작 */"마크", "지팡이" /* 수정가능지역 끝 */);
        // 마크(가) 지팡이(으)로 공격합니다.
        a전사.재공격();
        // 마크(가) 지팡이(으)로 공격합니다.

        a전사.재공격();
        // 마크(가) 지팡이(으)로 공격합니다.
    }
}
class 전사 {
    String 공격자명;
    String 무기명;

    void 공격(String 공격자, String 무기) {

        System.out.println(공격자+ "(이)가 " + 무기+ "(으)로 공격합니다.");

        공격자명 = 공격자;
        무기명 = 무기;

    }
    void 재공격() {
        System.out.printf(this.공격자명+ "(이)가 " + this.무기명 + "(으)로 공격합니다.\n");

    }
}

//class 전사 {
//    void 공격(String 공격자, String 무기){ // 공격() 괄호안에 String 이름을 넣어 내가 원하고자 하는걸 만들 수 있음
//                                            // 안 넣고 문자열을 넣으면 오류 발생!
//        System.out.println(공격자 + "(이)가 " + 무기 + "(으)로"+ "공격합니다.");
//
//    }
//
//}



// 문제 : `무기 a무기 = new 칼();` 가 실행되는 세부과정을 자세히 쓰세요.

//class Main {
//    public static void main(String[] args) {
//        // * double d = 5.5; 의 처리과정
//        // 1 : 실수 5.5가 생긴다.
//        // 2 : 오직 실수만 담을 수 있는 변수 d가 생성된다.
//        // 3 : d는 5.5가 자신안에 들어 올 수 있는지 판단한다.(가능)
//        // 4 : d변수에 실수 5.5가 들어간다.
//        double d = 5.5;
//
//        // * double dd = 5; 의 처리과정
//        // 1 : 정수 5가 생긴다.
//        // 2 : 오직 실수만 담을 수 있는 변수 dd가 생성된다.
//        // 3 : dd는 5가 자신안에 들어 올 수 있는지 판단한다.
//        // 4 : 5는 정수이기 때문에 들어 올 수 없다고 판단한다.(불가능)
//        // 5 : dd가 아쉬워하는 5에게 이렇게 이야기 합니다. `니가 실수로 변환될 수 있다면 들어올 수 있다.`
//        // 6 : 5는 자신의 형태를 버리고 실수화 한다. 즉 5.0으로 변신하다.(캐스팅, 또는 형변환)
//        // 7 : dd로 5.0이 들어간다.
//        double dd = 5;
//
//        // * int i = 5.5; 의 처리과정
//        // 1 : 실수 5.5가 생긴다.
//        // 2 : 오직 정수만 담을 수 있는 변수 i가 생성된다.
//        // 3 : i는 5.5가 자신에게 담길 수 있는지 체크한다.(불가능)
//        // 4 : i는 아쉬워하는 5.5에게 이렇게 이야기 합니다. `니가 정수가 된다면 들어올 수 있다.`
//        // 5 : 5.5는 도저히 불가능 요구를 받고 치명적인 에러를 발생시킨다.(캐스팅 불가능 으로 인한 에러)
//        //int i = 5.5;
//
//        // * 무기 a무기 = new 칼();의 처리과정
//        // 1 : 칼 객체 생성 -> 칼 리모콘이 생성
//        // 2 : 'new 칼();' 실행되면 이 코드가 '칼 리모콘'으로 변신한다.(바뀐다.)
//        // 3 : 오직 무기클래스(리모콘)을 연결 할 a무기를 생성한다.
//        // 4 : a무기 리모콘을 칼 리모콘에 넣을 수 있는가? 불가능 => 무기의 영역이 칼의 영역보다 더 넓기 때문에
//        // 5 : 칼 리모콘이 a무기 리모콘에 들어갈 수 있는가? 가능 => 무기의 내용물 안에는 칼이라는게 있기 때문에
//        // 6 : 칼 리모콘이 무기 리모콘으로 변신해 'a무기'로 들어간다.
//        무기 a무기 = new 칼();
//    }
//}
//
//class 무기 {
//
//}
//
//class 칼 {
//
//}



//itnerface와 abstract는 필수가 아니다. 없어도 구현가능


// abstract클래스를 사용하면 상속받는 클래스에는 구현부를 꼭 작성(재정의)
// abstract 하나 이상 갖으면 class 앞에  abstract작성

// abstract 문법(규칙)

// abstract class 클래스명 {
//  abstract void 이름();
//}
//class 클래스명1 extends 클래스명 {
//    void 이름() {
//        System.out.println();
//    }
//}

// interface: 순도 100% 추상 클래스 / interface를 사용하면  상속받는 클래스는 extends대신 implement사용하고  구현부에
// public void를 사용해야 함
// interface는 다중 상속이 가능

// interface 문법

//interface 클래스명 {
//     void 이름(){
//
//    }
//}
//class 클래스명1 implements 클래스명 {
//
//    public void 이름() {
//
//    }
//}

